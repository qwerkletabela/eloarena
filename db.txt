-- Tabela profili
create table if not exists profiles (
  id uuid primary key references auth.users on delete cascade,
  role text not null default 'user' check (role in ('user', 'admin')),
  display_name text,
  created_at timestamp with time zone default now()
);

-- RLS on
alter table profiles enable row level security;

-- Tylko właściciel widzi/aktualizuje swój profil
create policy "profiles: select own"
on profiles for select
using (id = auth.uid());

create policy "profiles: update own"
on profiles for update
using (id = auth.uid())
with check (id = auth.uid());

-- Trigger – auto insert profilu po rejestracji
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, display_name)
  values (new.id, coalesce(new.raw_user_meta_data->>'name', 'Nowy użytkownik'));
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();
-------------------------- tabela profiles-------------------------


1) Helper: funkcja is_admin()
create or replace function public.is_admin() returns boolean
language sql stable as $$
  select exists(
    select 1 from public.profiles p
    where p.id = auth.uid() and p.role = 'admin'
  );
$$;

2) Polityki z dostępem admina

Zastąp/uzupełnij obecne polityki, by admin widział/edytował wszystko:

-- SELECT: admin wszystko, user tylko siebie
drop policy if exists "profiles: select own" on profiles;
create policy "profiles: select admin or own"
on profiles for select
using (public.is_admin() or id = auth.uid());

-- UPDATE: admin wszystko, user tylko siebie
drop policy if exists "profiles: update own" on profiles;
create policy "profiles: update admin or own"
on profiles for update
using (public.is_admin() or id = auth.uid())
with check (public.is_admin() or id = auth.uid());

Drobne usprawnienia (opcjonalne)

Użyj skrótu typu: created_at timestamptz default now().

Jeśli chcesz śledzić zmiany, dodaj updated_at + trigger:

alter table profiles add column if not exists updated_at timestamptz default now();

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end; $$ language plpgsql;

drop trigger if exists set_profiles_updated_at on profiles;
create trigger set_profiles_updated_at
before update on profiles
for each row execute procedure public.set_updated_at();





------------ unikalność loginu (case-insensitive)------------------
create unique index if not exists profiles_username_key
  on public.profiles (lower(username));



------------------------dodanie email do tabeli profiles--------------
  alter table public.profiles add column if not exists email text;

create unique index if not exists profiles_email_key
  on public.profiles (lower(email));

-- uzupełnij istniejące rekordy z auth.users
update public.profiles p
set email = u.email
from auth.users u
where p.id = u.id and p.email is null;

-- zaktualizuj trigger: zapisuj tylko id i email (NIE username!)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email) values (new.id, new.email);
  return new;
end; $$ language plpgsql security definer;
