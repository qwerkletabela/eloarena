-- Tabela profili
create table if not exists profiles (
  id uuid primary key references auth.users on delete cascade,
  role text not null default 'user' check (role in ('user', 'admin')),
  display_name text,
  created_at timestamp with time zone default now()
);

-- RLS on
alter table profiles enable row level security;

-- Tylko właściciel widzi/aktualizuje swój profil
create policy "profiles: select own"
on profiles for select
using (id = auth.uid());

create policy "profiles: update own"
on profiles for update
using (id = auth.uid())
with check (id = auth.uid());

-- Trigger – auto insert profilu po rejestracji
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, display_name)
  values (new.id, coalesce(new.raw_user_meta_data->>'name', 'Nowy użytkownik'));
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();
-------------------------- tabela profiles-------------------------


1) Helper: funkcja is_admin()
create or replace function public.is_admin() returns boolean
language sql stable as $$
  select exists(
    select 1 from public.profiles p
    where p.id = auth.uid() and p.role = 'admin'
  );
$$;

2) Polityki z dostępem admina

Zastąp/uzupełnij obecne polityki, by admin widział/edytował wszystko:

-- SELECT: admin wszystko, user tylko siebie
drop policy if exists "profiles: select own" on profiles;
create policy "profiles: select admin or own"
on profiles for select
using (public.is_admin() or id = auth.uid());

-- UPDATE: admin wszystko, user tylko siebie
drop policy if exists "profiles: update own" on profiles;
create policy "profiles: update admin or own"
on profiles for update
using (public.is_admin() or id = auth.uid())
with check (public.is_admin() or id = auth.uid());

Drobne usprawnienia (opcjonalne)

Użyj skrótu typu: created_at timestamptz default now().

Jeśli chcesz śledzić zmiany, dodaj updated_at + trigger:

alter table profiles add column if not exists updated_at timestamptz default now();

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end; $$ language plpgsql;

drop trigger if exists set_profiles_updated_at on profiles;
create trigger set_profiles_updated_at
before update on profiles
for each row execute procedure public.set_updated_at();





------------ unikalność loginu (case-insensitive)------------------
create unique index if not exists profiles_username_key
  on public.profiles (lower(username));



------------------------dodanie email do tabeli profiles--------------
  alter table public.profiles add column if not exists email text;

create unique index if not exists profiles_email_key
  on public.profiles (lower(email));

-- uzupełnij istniejące rekordy z auth.users
update public.profiles p
set email = u.email
from auth.users u
where p.id = u.id and p.email is null;

-- zaktualizuj trigger: zapisuj tylko id i email (NIE username!)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email) values (new.id, new.email);
  return new;
end; $$ language plpgsql security definer;






--------------tabela gracze------------------

-- ======================= DEPENDENCJE (IMMUTABLE) ============================
-- Rozszerzenie unaccent (do usuwania ogonków)
create extension if not exists unaccent with schema public;

-- Immutable wrapper na unaccent (niektóre instancje wymagają)
create or replace function public.unaccent_imm(t text)
returns text
language sql
immutable
as $$
  select public.unaccent(t)
$$;

-- Normalizacja tekstu: lower + unaccent + pojedyncze spacje (IMMUTABLE)
create or replace function public.norm_txt(t text)
returns text
language sql
immutable
as $$
  select
    trim(
      regexp_replace(
        public.unaccent_imm(lower(coalesce(t, ''))),
        '\s+',
        ' ',
        'g'
      )
    )
$$;

-- =========================== TABELA GRACZ ===================================
create table if not exists public.gracz (
  id               uuid primary key default gen_random_uuid(),

  -- dane oryginalne (z ogonkami)
  imie             text not null,
  nazwisko         text not null,
  rok_urodzenia    int,
  miasto           text,
  wojewodztwo      text,

  -- ranking i statystyki
  ranking          numeric(10,4) not null default 1200.0000,
  games_played     int not null default 0,
  wins             int not null default 0,
  last_played_at   timestamptz,

  -- znormalizowane kolumny (do wyszukiwania/unikatów) – dodamy niżej alterem,
  -- bo na niektórych PG łatwiej tak przejść przy ponownych uruchomieniach:
  -- nazwisko_norm generated ...
  -- fullname_norm generated ...

  created_at       timestamptz not null default now(),
  updated_at       timestamptz not null default now(),

  -- walidacje
  constraint gracz_rok_urodzenia_chk
    check (rok_urodzenia is null or rok_urodzenia between 1900 and extract(year from now())::int),
  constraint gracz_nonnegatives_chk
    check (games_played >= 0 and wins >= 0),
  constraint gracz_ranking_chk
    check (ranking >= 0)
);

-- Dodaj kolumny generowane (bezpiecznie, jeśli ich jeszcze nie ma)
do $$
begin
  if not exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='gracz' and column_name='nazwisko_norm'
  ) then
    alter table public.gracz
      add column nazwisko_norm text generated always as (public.norm_txt(nazwisko)) stored;
  end if;

  if not exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='gracz' and column_name='fullname_norm'
  ) then
    alter table public.gracz
      add column fullname_norm text generated always as (public.norm_txt(imie || ' ' || nazwisko)) stored;
  end if;
end $$;

-- Unikat po fullname_norm (idempotentnie)
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conrelid = 'public.gracz'::regclass
      and conname  = 'uniq_gracz_fullname_norm'
  ) then
    alter table public.gracz
      add constraint uniq_gracz_fullname_norm unique (fullname_norm);
  end if;
end $$;

-- Indeksy pomocnicze
create index if not exists idx_gracz_nazwisko_norm on public.gracz (nazwisko_norm);
create index if not exists idx_gracz_last_played   on public.gracz (last_played_at desc);

-- ======================= TRIGGER updated_at =================================
create or replace function public.set_gracz_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists set_gracz_updated_at on public.gracz;
create trigger set_gracz_updated_at
before update on public.gracz
for each row execute procedure public.set_gracz_updated_at();

-- ============================ RLS / POLITYKI ================================
alter table public.gracz enable row level security;

-- usuń stare polityki, jeśli były
drop policy if exists "gracz: select public" on public.gracz;
drop policy if exists "gracz: write admin"  on public.gracz;

-- publiczny odczyt
create policy "gracz: select public"
on public.gracz
for select
to anon, authenticated
using (true);

-- zapis tylko admin
create policy "gracz: write admin"
on public.gracz
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

-- upewnij się, że is_admin jest dostępne dla ról
grant execute on function public.is_admin() to anon, authenticated;





------------tabela gracz---------------------



-- ================= DEPENDENCJE (IMMUTABLE) =================
create extension if not exists unaccent with schema public;

create or replace function public.unaccent_imm(t text)
returns text
language sql
immutable
as $$
  select public.unaccent(t)
$$;

create or replace function public.norm_txt(t text)
returns text
language sql
immutable
as $$
  select
    trim(
      regexp_replace(
        public.unaccent_imm(lower(coalesce(t, ''))),
        '\s+',
        ' ',
        'g'
      )
    )
$$;

-- ===================== TABELA GRACZ ========================
create table if not exists public.gracz (
  id               uuid primary key default gen_random_uuid(),

  imie             text not null,
  nazwisko         text not null,
  rok_urodzenia    int,
  miasto           text,
  wojewodztwo      text,

  ranking          numeric(10,4) not null default 1200.0000,
  games_played     int not null default 0,
  wins             int not null default 0,
  last_played_at   timestamptz,

  created_at       timestamptz not null default now(),
  updated_at       timestamptz not null default now(),

  constraint gracz_rok_urodzenia_chk
    check (rok_urodzenia is null or rok_urodzenia between 1900 and extract(year from now())::int),
  constraint gracz_nonnegatives_chk
    check (games_played >= 0 and wins >= 0),
  constraint gracz_ranking_chk
    check (ranking >= 0)
);

-- kolumny generowane (normalizacja do wyszukiwania/unikatu)
do $$
begin
  if not exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='gracz' and column_name='nazwisko_norm'
  ) then
    alter table public.gracz
      add column nazwisko_norm text generated always as (public.norm_txt(nazwisko)) stored;
  end if;

  if not exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='gracz' and column_name='fullname_norm'
  ) then
    alter table public.gracz
      add column fullname_norm text generated always as (public.norm_txt(imie || ' ' || nazwisko)) stored;
  end if;
end $$;

-- unikat po fullname_norm
do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conrelid = 'public.gracz'::regclass
      and conname  = 'uniq_gracz_fullname_norm'
  ) then
    alter table public.gracz
      add constraint uniq_gracz_fullname_norm unique (fullname_norm);
  end if;
end $$;

-- indeksy pomocnicze
create index if not exists idx_gracz_nazwisko_norm on public.gracz (nazwisko_norm);
create index if not exists idx_gracz_last_played   on public.gracz (last_played_at desc);

-- trigger updated_at
create or replace function public.set_gracz_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists set_gracz_updated_at on public.gracz;
create trigger set_gracz_updated_at
before update on public.gracz
for each row execute procedure public.set_gracz_updated_at();

-- ============== RLS: odczyt publiczny, zapis tylko admin =================
alter table public.gracz enable row level security;

drop policy if exists "gracz: select public" on public.gracz;
drop policy if exists "gracz: write admin"  on public.gracz;

create policy "gracz: select public"
on public.gracz
for select
to anon, authenticated
using (true);

create policy "gracz: write admin"
on public.gracz
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

grant execute on function public.is_admin() to anon, authenticated;
